#summary A getting started guide.
#labels Featured
=Getting Started Guide=
_This guide is very brief and incomplete. Feel free to fix or improve it_

==Installation==
For maven users, the easiest way to get going is to add the following repository and dependency to your project. 

_Please verify the latest version_:


{{{
<repository>
   <id>orika-snapshot</id>
   <url>https://repository-orika.forge.cloudbees.com/snapshot</url>
</repository>
...
<dependency>
   <groupId>ma.glasnost.orika</groupId>
   <artifactId>orika-core</artifactId>
   <version>1.0-SNAPSHOT</version>
</dependency> 
}}}

If you do not use maven please download the latest version of the archive zip with dependencies and put it on your classpath.


Once your project configured you can start the following tutorial.

===3rd Party Dependencies===

Orika use javassist to generate byte-code dynamically. If you're downloading and installing the compiled jar in your local m2 repository rather than building from source using maven, you will not get any of the transitive dependencies



== Tutorial ==

=== Setup the mapping factory ===

The get an instance of MapperFacade initialise a MapperFactory:

{{{
MapperFactory factory = MappingUtil.getMapperFactory();
factory.registerClassMap(ClassMapBuilder.map(Order.class,OrderDTO.class)
  .field("product.state.type.label", "stateLabel")
  .field("product.name", "productName").toClassMap());
    	
factory.build();

factory.getMapperFacade();
}}}

=== Reference ====

n this example we will show you how to map from a class A to another class B and vice versa.
Let’s have a look at our domain model:

*Product (A) Source :*
{{{
public class Product {

	private String productName;

	private String productDescription;

	private Double price;

	private Boolean availability;

	// getters & setters
	
}
}}}

*ProductDto (B) Destination :*

{{{
public class ProductDto {

	private String productName;

	private String description;

	private BigDecimal price;

	private Boolean availability;

	// getters & setters
}
}}}

Note that we have explicitly chosen different and alike attributes names and types.

=== Auto mapping ===

==== Map from Product to ProductDto ====

*Result (Orika-AutoMapping) :*

Orika will automatically find all attributes with the same name and type and map them.

NB: remember that, declaring a custom mapper and/or a converter override the orika auto-mapping functionality, the byDefault() function set it  active again, this was deliberately done this way to give developers full  hands on their mapping.

{{{
// register the auto-mapping function
mapperFactory.registerClassMap(ClassMapBuilder.map(Product.class,ProductDto.class).byDefault().toClassMap());
}}}


=== Custom Mapper ===

*Let’s take now a closer look at our Dto:*

The description field in our case has nothing to do with the former one from the product class, this field is now a set of information collected from other fields, let’s say that the description should look something like this:
* Description example: The Dreamcast is a fabulous product which only cost 150
* Description in java: {{{ "The " + product.getProductName() +" is a fabulous product which only cost " + product.getPrice() }}}

For specific field we have specific treatment, in this case we will create and register a custom mapper :

{{{
// register your custom mapper
ClassMapBuilder<ProductDto, Product> builder = ClassMapBuilder.map(ProductDto.class, Product.class);
builder.customize(new MapperBase<ProductDto, Product>() {
	
// create your custom mapper				
@Override
public void mapBtoA( Product b,  ProductDto a, MappingContext  context) {
a.setDescription("The " + b.getProductName() + " is a fabulous  product which only cost  " + b.getPrice());

}});
mapperFactory.registerClassMap(builder.byDefault().toClassMap());

}}}