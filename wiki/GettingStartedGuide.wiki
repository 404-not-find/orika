#labels Featured
=Getting Started Guide=

<wiki:toc max_depth="3" />

_This guide is very brief and incomplete. Feel free to fix or improve it_

==Installation==
For maven users, the easiest way to get going is to add the following repository and dependency to your project. 

_Please verify the latest version_:


{{{
<repository>
   <id>orika-snapshot</id>
   <url>https://repository-orika.forge.cloudbees.com/snapshot</url>
</repository>
...
<dependency>
   <groupId>ma.glasnost.orika</groupId>
   <artifactId>orika-core</artifactId>
   <version>1.0-SNAPSHOT</version>
</dependency> 
}}}

If you do not use maven please download the latest version of the archive zip with dependencies and put it on your classpath.


Once your project configured you can start the following tutorial.

===3rd Party Dependencies===

Orika use javassist to generate byte-code dynamically. If you're downloading and installing the compiled jar in your local m2 repository rather than building from source using maven, you will not get any of the transitive dependencies



== Tutorial ==

=== Setup the mapping factory ===

The get an instance of MapperFacade initialise a MapperFactory:

{{{
MapperFactory factory = MappingUtil.getMapperFactory();
factory.registerClassMap(ClassMapBuilder.map(Order.class,OrderDTO.class)
  .field("product.state.type.label", "stateLabel")
  .field("product.name", "productName").toClassMap());
    	
factory.build();

factory.getMapperFacade();
}}}

=== Reference ====

n this example we will show you how to map from a class A to another class B and vice versa.
Let’s have a look at our domain model:

*Product (A) Source :*
{{{
public class Product {

	private String productName;

	private String productDescription;

	private Double price;

	private Boolean availability;

	// getters & setters
	
}
}}}

*ProductDto (B) Destination :*

{{{
public class ProductDto {

	private String productName;

	private String description;

	private BigDecimal price;

	private Boolean availability;

	// getters & setters
}
}}}

Note that we have explicitly chosen different and alike attributes names and types.

=== Auto mapping ===

==== Map from Product to ProductDto ====

*Result (Orika-AutoMapping) :*

Orika will automatically find all attributes with the same name and type and map them.

NB: remember that, declaring a custom mapper and/or a converter override the orika auto-mapping functionality, the byDefault() function set it  active again, this was deliberately done this way to give developers full  hands on their mapping.

{{{
// register the auto-mapping function
mapperFactory.registerClassMap(ClassMapBuilder.map(Product.class,ProductDto.class).byDefault().toClassMap());
}}}


=== Custom Mapper ===

*Let’s take now a closer look at our Dto:*

The description field in our case has nothing to do with the former one from the product class, this field is now a set of information collected from other fields, let’s say that the description should look something like this:
* Description example: The Dreamcast is a fabulous product which only cost 150
* Description in java: {{{ "The " + product.getProductName() +" is a fabulous product which only cost " + product.getPrice() }}}

For specific field we have specific treatment, in this case we will create and register a custom mapper :

{{{
// register your custom mapper
ClassMapBuilder<ProductDto, Product> builder = ClassMapBuilder.map(ProductDto.class, Product.class);
builder.customize(new MapperBase<ProductDto, Product>() {
	
// create your custom mapper				
@Override
public void mapBtoA( Product b,  ProductDto a, MappingContext  context) {
a.setDescription("The " + b.getProductName() + " is a fabulous  product which only cost  " + b.getPrice());

}});
mapperFactory.registerClassMap(builder.byDefault().toClassMap());

}}}


=== Converter ===

Let’s move now to the price, in our case we want to format the price:
  * Price in our product class is a Double
  * Price in our Dto class is a BigDecimal
For this case we need to create a converter:

{{{
// register your converter
mapperFactory.registerConverter(new ConverterBase<Double, String>() {

        // converter
	public BigDecimal convert(Double source) throws ConverterException {
		return new BigDecimal(source);
	}
});
}}}


=== Mapping fields with different name ===


Is an easy task, you should just point for the name of the attribute in the class A and the supposed match in the class B , keep in mind that the fields should be of the same type ,otherwise use a converter.

{{{
mapperFactory.registerClassMap(ClassMapBuilder.map(Product.class,ProductDto.class).field("productDescription", "description").byDefault().toClassMap());
}}}


=== Nested property ===


In some cases the class we’re mapping from is not a mirror of the one we’re mapping to, attribute we’re seeking can be at a different depth, use nested property expression to access attribute at different level/depth.
We are going to introduce the order class:

An order contains only one product at a time.

Our Dto diagram contains a new attribute the orderNum which is in our case the product name.

{{{
// register the nested property expression
mapperFactory.registerClassMap(ClassMapBuilder.map(Order.class,OrderDto.class).field("product.productName", "orderNum").byDefault().toClassMap());
}}}

=== Collections ===

In reality an order contains a set of products:
{{{
// register product and order
mapperFactory.registerClassMap(ClassMapBuilder.map(Product.class,
ProductDto.class).field("productDescription", "description")
.byDefault().toClassMap());

mapperFactory.registerClassMap(ClassMapBuilder.map(Order.class,
OrderDto.class).field("products", "productsDto").byDefault()
.toClassMap());

}}}

You have guessed right, there is no special treatment for collections case, since it’s implicit, Orika will automatically detects the collection inside your source object and map it to the destination.

=== Bi-directional mapping ====

Let’s have a look at our bi-directional domain, 

Our dto model :

{{{
BookDto bookDto = mapperFacade.map(book, BookDto.class);
}}}

As you can see, nothing has changed, and of course the destination object will have bi-directional references as well.

=== Primitives ===


Orika will map from primitives to their respective wrapper and vice versa automatically.

=== Inheritance ===


As of the primitives Orika detect inheritance and map automatically child and parent object.

=== Object factories ===

In some cases we want to add an object factory to our mapping processing, let’s take for instance a case where we have a Person with a default address that we want Orika to add automatically whenever facing a PersonDto.
Let’s introduce the person domain’s model:
                        
Dto’s model :

{{{
public class PersonFactory implements ObjectFactory<PersonDto> {

	@Override
	public PersonDto create() {
		PersonDto personDto = new PersonDto();
		// set the default adress
		personDto.setAdressDto(new AdressDto("Morocco", "Casablanca"));
			return personDto;
	}

	@Override
	public Class<PersonDto> getTargetClass() {
		return PersonDto.class;
	}

}

}}}

Your factory must implements Orika’s ObjectFactory, then all you will have to do is to implement the create () method, and indicate the type to be expected by the object factory in the getTargetClass() method.

{{{
mapperFactory.registerObjectFactory(new PersonFactory(),PersonDto.class);
}}}

Don’t forget to register your Object factory.

NB: In sum, always remember when using orika, that it will automatically do everything for you, you should be concerned by treat only your special cases.

=== Proxy ====

_Implemented but not yet documented_

== Summary ==

Where not going to start a discussion on whether use or not a dto but we are going to illustrate some cases in which you may need mapping (Orika):
 * Multi layered applications
 * DDD you need for example a data mapper between bounded context



		